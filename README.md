# 해당 용도 
수업을 들으며 기억해야겠다 혹은 , 따로 기록하고 싶은 내용들을 저장하는 공간 
복습차원이라 생각하면 될것같습니다. 


# 하노이 탑 쌓기 

Input : n개의 원반이 봉 a에 크기 순으로 쌓여있다.

output : n개의 원반이 봉 b에 크기 순으로 쌓여있다.

procedure : 
               hanoi_Tower(n,a,b,c) { 
                 if (n > 0 ) { 
  	                   hanoi Tower( n-1 , a, c, b) ; 
                                봉 a의 마지막 원반을 봉 b로 옮김 
                                hanoi_Tower(n-1 , c, b ,a );
                   } 
              } 


# 1주차 과제 

유클리드 알고리즘 중 하나를 선택하여 48과 54의 최대 공약수를 풀이과정과 함께 제시하시오.

최대 공약수 : 6 

1 if (b = 0 ) return a 

2. return Euclid2 (b , a mob b)

다음을 이용하였고 또한 

GCD(u,v) = GCD(v,u)

이부분을 이용해 

GCD(48 , 54) = GCD(54,48)과 같다는것을 알게되었습니다. 



그래서 계산하였던결과 

GCD(54,48) => GCD(48 , 6) => GCD( 6,0) 

이처럼 최대공약수가 6이라는것을 확인할수 있었습니다.



*또한 파이썬을 통해 코드로 구현했을때 다음과 같이 해답을 찾을수 있었습니다. 



a = 48
b = 54

while True :
    r = int(a) % int(b)
    if r == 0 :
        gcd = b
        break

    elif r != 0 :
        a = b
        b = r

print(gcd)


# 2주차 과제 

합병정렬과 퀵정렬은 분할정복 알고리즘으로 분류된다.

두 알고리즘의 주요 차이점을 1가지만 작성하시오.


두 알고리즘의 차이점에 대해 이야기하자면 



합병정렬은 분할 후 각 분할된 수들을 정복하며 순서대로 나열하지만, 

퀵정렬의 경우 피봇값을 기준으로 정복 후 각 자리에 맞게 분할하는 순서로 진행이 됩니다. 


# 3주차 과제 

n번째 피보나치 수 F(n)을 구하는 알고리즘을 분할정복 기법을 이용하여 재귀적으로 작성하였다.

F(n) {
  if (n=0 or n=1) then return 1;
  else return (                     );
}

괄호(      )안에 들어갈 문장을 작성하시오.
그리고, 위 알고리즘이 비효율적인 이유를 간단히 작성하시오.

F(n) {
  if (n=0 or n=1) then return 1;
  else return (    F(n-1) + F(n-2)      );
}



비효율적인 이유는 

1. 해당 분할 정복기법을 활용하면 분할을 하면 할수록 값이 더 커지며, 큰 수를 분할하여 계산할 경우 밑으로 내려가면 내려갈수록 값이 많아지기 때문에 시간이 더 많이 걸린다. 

2.  같은 값의 계산결과를 가지고있더라도 값을 기억하지 못하기 때문에 같은 계산에도 계속하여 다시 계산을하기에 시간이 많이 걸린다.


